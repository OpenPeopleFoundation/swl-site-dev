-- Customers and Customer Interactions schema
-- Core CRM tables for guest relationship tracking

-- Customers table (CRM core)
create table if not exists public.customers (
  id integer generated by default as identity primary key,
  name text,
  first_name text,
  last_name text,
  email text,
  phone text,
  contact text,
  notes text,
  tags text[] default '{}',
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

comment on table public.customers is 'Core customer/guest records for CRM';

create index if not exists customers_email_idx
  on public.customers (email);

create index if not exists customers_phone_idx
  on public.customers (phone);

create unique index if not exists customers_email_lower_uidx
  on public.customers ((lower(email)))
  where email is not null;

-- Customer Interactions table (interaction logging)
create table if not exists public.customer_interactions (
  id bigint generated always as identity primary key,
  customer_id integer references public.customers(id) on delete set null,
  email text,
  interaction_type text not null,
  channel text default 'site',
  related_table text,
  related_id text,
  summary text,
  payload jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

comment on table public.customer_interactions is 'Log of all customer touchpoints across channels';

-- Reservations table (restaurant reservations)
create table if not exists public.reservations (
  id integer generated by default as identity primary key,
  customer_id integer references public.customers(id) on delete set null,
  guest_name text,
  guest_contact text,
  party_size integer,
  reservation_time timestamp without time zone,
  expected_table_ids integer[],
  preassigned_seat_map jsonb,
  status text default 'pending',
  occasion text,
  allergies text[],
  notes text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

comment on table public.reservations is 'Restaurant table reservations';

create index if not exists reservations_customer_idx
  on public.reservations (customer_id);

create index if not exists reservations_status_idx
  on public.reservations (status);

create index if not exists reservations_time_idx
  on public.reservations (reservation_time);

create index if not exists customer_interactions_customer_idx
  on public.customer_interactions (customer_id);

create index if not exists customer_interactions_type_idx
  on public.customer_interactions (interaction_type, created_at desc);

create index if not exists customer_interactions_email_idx
  on public.customer_interactions ((lower(email)))
  where email is not null;

-- Updated_at trigger for customers
create or replace function public.set_customers_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_customers_updated on public.customers;
create trigger trg_customers_updated
before update on public.customers
for each row
execute procedure public.set_customers_updated_at();

-- RLS policies
alter table public.customers enable row level security;

drop policy if exists "Service role can manage customers" on public.customers;
create policy "Service role can manage customers"
on public.customers
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

alter table public.customer_interactions enable row level security;

drop policy if exists "Service role can manage interactions" on public.customer_interactions;
create policy "Service role can manage interactions"
on public.customer_interactions
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

-- Helper function to get or create customer by email
create or replace function public.get_or_create_customer_id(
  p_email text,
  p_full_name text default null,
  p_phone text default null
)
returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  existing_id integer;
  clean_email text := nullif(trim(p_email), '');
  clean_phone text := nullif(trim(p_phone), '');
  match_email text := case when clean_email is not null then lower(clean_email) end;
  trimmed_name text := nullif(trim(p_full_name), '');
  first_value text := null;
  last_value text := null;
begin
  if trimmed_name is not null then
    first_value := split_part(trimmed_name, ' ', 1);
    last_value := nullif(regexp_replace(trimmed_name, '^\S+\s*', ''), '');
  end if;

  -- Try email match first
  if match_email is not null then
    select id into existing_id
    from customers
    where lower(email) = match_email
    limit 1;
  end if;

  -- Try phone match if no email match
  if existing_id is null and clean_phone is not null then
    select id into existing_id
    from customers
    where phone = clean_phone
    limit 1;
  end if;

  -- Create new customer if not found
  if existing_id is null then
    insert into customers (email, phone, name, first_name, last_name)
    values (clean_email, clean_phone, trimmed_name, first_value, last_value)
    returning id into existing_id;
  else
    -- Update existing record with any new info
    update customers
    set
      email = coalesce(customers.email, clean_email),
      phone = coalesce(customers.phone, clean_phone),
      name = coalesce(customers.name, trimmed_name),
      first_name = coalesce(customers.first_name, first_value),
      last_name = coalesce(customers.last_name, last_value),
      updated_at = now()
    where id = existing_id;
  end if;

  return existing_id;
end;
$$;
